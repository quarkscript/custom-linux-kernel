#!/bin/bash
## Tune cpu.patch to local hw
## Req: grep, gcc, sed, lscpu, hash, sha512sum,
##                    /proc/cpuinfo, cpu.patch
## Use: ./localcpu
## Author Andrew S.
## Licence GPL
## Tested on Arch Linux and Linux Kernel source 4.20.12
## https://github.com/quarkscript/linux-kernel-cpu-patch

if [ ! -e "cpu.patch" ]; then
echo "-------------------
cpu.patch not found
nothing to tune
-------------------"
elif ! (hash gcc 2>/dev/null); then
echo "-------------------
gcc not found, exit
-------------------"
elif [ -e "localcpu.patch" ]; then
echo "---------------------------
localcpu.patch is present
Tunning will not run

To gen a new localcpu.patch
firstly remove existed
---------------------------"
else
    if [ ! -e "cxxflags.txt" ]; then
        if [ ! -e "sfslib" ]; then
            wget https://github.com/quarkscript/Simple_func_scripts/raw/master/sfslib
            chmod +x sfslib
        fi
        ./sfslib cxx_flags
    fi
    cp cpu.patch localcpu.patch
    count=0
    for k in $(cat cxxflags.txt | sed -e 's/--param//g'); do
        if [ "$count" -eq "0" ]; then
            for i in core2 nehalem westmere silvermont sandybridge ivybridge haswell broadwell skylake k8-sse3 amdfam10 barcelona btver1 bdver1 bdver2 bdver3 btver2
                do
                    if (grep $i cxxflags.txt -q); then arrch=$i; fi
                done
                if [ "$arrch" == "" ]; then 
                    arrch=native
                    echo -----------------------------------------------------
                    echo 'Current CPU is not fully supported by patch source.'
                    echo 'Custom gcc flags will be add to native optimization.'
                fi
                if $(echo $k | grep -q march)&&$(echo $arrch | grep -q native); then kk='-march=native'; else kk=$k; fi
                enabl="$kk "
                call_cc="$""(call cc-option,$kk"
        else
            if $(echo $k | grep -q mtune)&&$(echo $arrch | grep -q native); then kk='-mtune=native'; else kk=$k; fi
            if $(echo $k | grep cache -q); then 
                enabl+="--param $kk "
                call_cc+=",$""(call cc-option,--param $kk)"
            else
                enabl+="$kk "
                call_cc+=",$""(call cc-option,$kk)"
            fi
        fi
        count=$(($count+1))
    done
    call_cc+=")"
    p_t='Enables -march='$arrch
    l_n=$(grep -n "$p_t" localcpu.patch | sed -e 's/:.*//g')
    head -n $(($l_n-1)) localcpu.patch >patch.patch
    echo "+	  Enables "$enabl>>patch.patch
    tail -n +$(($l_n+1)) localcpu.patch >>patch.patch
    rm -f localcpu.patch
    cp -f patch.patch localcpu.patch
    rm -f patch.patch
    p_t='$(call cc-option,-march='$arrch',$(call cc-option,-mtune='$arrch'))'
    l_n=$(grep -n "$p_t" localcpu.patch | sed -e 's/:.*//g')
    head -n $(($l_n-1)) localcpu.patch >patch.patch
    echo "+        "$call_cc>>patch.patch
    tail -n +$(($l_n+1)) localcpu.patch >>patch.patch
    rm -f localcpu.patch
    cp -f patch.patch localcpu.patch
    rm -f patch.patch
    echo "-----------------------------------------------------
Linux kernel can be better optimized to 
$(grep 'model name' /proc/cpuinfo --max-count=1 | sed 's/.*\: //g' | sed 's/  / /g' | sed 's/  / /g' | sed 's/  / /g')
just patch kernel source with localcpu.patch and
select '$arrch' CPU-family while configuring it
-----------------------------------------------------"
    if [ ! "$(sha512sum cpu.patch | sed -e 's/  cpu.patch//')" == "a47056edeac72c730cecfda766a3941bb004ee4523cfd3a276e9d4c717ae51c8c89f992ee7f0dfffe313846056e4f5bad58f92f64806cba4933d61fdad7cce13" ]
        then
        echo 'cpu.patch is differ from expexted,
wrong source can leads to fails. Be aware.
'
    fi
    rm -f /tmp/hw_test.txt /tmp/capabilities.txt 
fi
