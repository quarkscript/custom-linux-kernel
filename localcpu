#!/bin/bash
## Tune cpu.patch to local hw
## Req: grep, gcc, sed, lscpu, hash, sha512sum,
##                                   cpu.patch
## Use: ./localcpu
## Author Andrew S.
## Licence GPL
## Tested on Arch Linux and Linux Kernel source 5.7.3
## https://github.com/quarkscript/old-pc-linux-kernel

if [ ! -e "cpu.patch" ]; then
    echo "
-------------------
cpu.patch not found
nothing to tune
-------------------"
elif ! (hash gcc 2>/dev/null); then
    echo "
-------------------
gcc not found, exit
-------------------"
elif [ -e "localcpu.patch" ]; then
    echo "
---------------------------
localcpu.patch is present
Tunning will not run

to gen a new localcpu.patch
you must remove existing
---------------------------"
else
    if [ "$(gcc -v 2>&1 | grep version | sed 's/.*version //g' | sed 's/\..*//g')" != "10" ]; then
        echo "seems like gcc ver < 10.x"
        sleep 2
    fi

    if [ ! -e "cxxflags.txt" ]; then
        if [ ! -e "sfslib" ]; then
            wget https://github.com/quarkscript/Simple_func_scripts/raw/master/sfslib
            chmod +x sfslib
        fi
        ./sfslib cxx_flags
    fi
    
    cp cpu.patch localcpu.patch
    count=0
    for k in $(cat cxxflags.txt | sed -e 's/--param//g'); do
        if [ "$count" -eq "0" ]; then
            enabl="$k "
            call_cc="$""(call cc-option,$k"
            for i in core2 nehalem westmere silvermont sandybridge ivybridge haswell broadwell skylake k8-sse3 amdfam10 barcelona btver1 bdver1 bdver2 bdver3 btver2 bdver4 znver1 znver2 nocona skylake-avx512 cannonlake icelake cascadelake cooperlake tigerlake; do
                if (grep $i cxxflags.txt -q); then
                    arrch=$i
                fi
            done
        else
            if $(echo $k | grep cache -q); then 
                enabl+="--param $k "
                call_cc+=",$""(call cc-option,--param $k)"
            else
                enabl+="$k "
                call_cc+=",$""(call cc-option,$k)"
            fi
        fi
        count=$(($count+1))
    done
    call_cc+=")"

    if [ -z $arrch ]; then
        echo "
-----------------------------------------------------
CPU type is undetected, tuning of cpu.patch
is not possible for now. It is better to use native
or generic optimizations '('do not forget to patch
kernel source with original cpu.patch')'
-----------------------------------------------------"
        rm -f localcpu.patch
    else
        p_t='Enables -march='$arrch
        l_n=$(grep -n "$p_t" localcpu.patch | sed -e 's/:.*//g')
        head -n $(($l_n-1)) localcpu.patch >patch.patch
        echo "+	  Enables "$enabl>>patch.patch
        tail -n +$(($l_n+1)) localcpu.patch >>patch.patch
        rm -f localcpu.patch
        cp -f patch.patch localcpu.patch
        rm -f patch.patch
        p_t='$(call cc-option,-march='$arrch',$(call cc-option,-mtune='$arrch'))'
        l_n=$(grep -n "$p_t" localcpu.patch | sed -e 's/:.*//g')
        head -n $(($l_n-1)) localcpu.patch >patch.patch
        echo "+        "$call_cc>>patch.patch
        tail -n +$(($l_n+1)) localcpu.patch >>patch.patch
        rm -f localcpu.patch
        cp -f patch.patch localcpu.patch
        rm -f patch.patch
        echo "
-----------------------------------------------------
Linux kernel could be better optimized to 
CPU $(echo $(grep 'model name' /proc/cpuinfo --max-count=1) | sed 's/  //g')
just patch kernel source with localcpu.patch and
select '$arrch' CPU-family while configuring it
-----------------------------------------------------"
sleep 2
    fi
    if [ ! "$(sha512sum cpu.patch | sed -e 's/  cpu.patch//')" == "8dc588bdaa8dd9ec06f2df14b42f6d627c0ee7d3ec32684d4bc54b8cb24f6038e9280fa451affbb2c93c73f2592121aa15cc0552dcb784e73ade3a4391d4651d" ]; then
        echo "
cpu.patch is differ from the expexted..
Wrong source can leads to fails. Be aware"
sleep 2
    fi
fi
